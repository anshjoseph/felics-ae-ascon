#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-3.0-or-later
# SPDX-FileCopyrightText: 2019 Airbus Cybersecurity SAS

from argparse import ArgumentParser
from collections import defaultdict, OrderedDict
from importlib import import_module
import json
from os import path
import re

from felics import ARCHITECTURES, METRICS


_CONTEXT = ('cipher_name', 'version', 'compiler_options')

_COLUMNS = _CONTEXT + METRICS

_COLUMN_NAMES = {
    'en': {
        'cipher_name': '',
        'version': 'Version',
        'compiler_options': 'CFLAGS',
        'code_size': 'Code size (B)',
        'code_ram': 'RAM (B)',
        'code_time': 'Execution time (cycles)'
    },
    'fr': {
        'cipher_name': '',
        'version': 'Version',
        'compiler_options': 'CFLAGS',
        'code_size': 'ROM (octets)',
        'code_ram': 'RAM (octets)',
        'code_time': "Temps d'exÃ©cution (cycles)"
    }
}


def _parse_info(argument):
    if argument[0] == '-':
        available = set(_COLUMNS)
        blacklist = set(argument[1:].split(','))
        requested = available-blacklist
    else:
        requested = set(argument.split(','))

    return sorted(requested, key=_COLUMNS.index)


def _parse_sort_order(argument):
    return argument.split(',')


def _parse_filter(argument):
    patterns = dict(
        subfilter.split('=') for subfilter in argument.split(',')
    )

    def accept_setup(setup):
        return all(
            re.match(pattern, setup[key])
            for key, pattern in patterns.items()
        )

    return accept_setup


def _parse_arguments():
    parser = ArgumentParser()

    parser.add_argument('-o', '--out', dest='output')

    parser.add_argument(
        '-s', '--sort-by', default=('compiler_options', 'cipher_name'),
        type=_parse_sort_order, metavar='KEY[,KEY...]'
    )

    parser.add_argument(
        '-f', '--filter', default=lambda setup: True, type=_parse_filter,
        metavar='KEY=REGEX[,KEY=REGEX...]'
    )

    parser.add_argument(
        '-i', '--info', default=_COLUMNS, type=_parse_info,
        metavar='[-INFO:...|INFO:...]'
    )

    parser.add_argument(
        '-l', '--table-label', default='table:bench-soft-{arch}'
    )

    parser.add_argument(
        '-c', '--table-caption', default='Performance results on {arch}.'
    )

    parser.add_argument(
        '--language', default='en', choices=tuple(_COLUMN_NAMES.keys())
    )

    parser.add_argument('results', metavar='JSON-RESULTS')

    return parser.parse_args()


def _sort_setups(setups, keys):
    def make_key(setup):
        return tuple(setup[k] for k in keys)

    return sorted(setups, key=make_key)


def _group_setups(setups, sort_keys, predicate):
    setups_by_arch = defaultdict(list)

    archs = {a.codename: a for a in ARCHITECTURES}

    for setup in setups:
        if predicate(setup):
            arch = archs[setup['architecture']]
            setups_by_arch[arch].append(setup)

    return OrderedDict(
        (arch, _sort_setups(setups_by_arch[arch], sort_keys))
        for arch in ARCHITECTURES
        if arch in setups_by_arch
    )


class SpreadsheetWriter:

    def __init__(self, output, columns):
        self._output = output
        self._columns = columns

    def _make_row(self, setup):
        return tuple(setup[c] for c in self._columns)

    def _make_rows(self, data):
        header = tuple(self._columns.values())
        rows = tuple(self._make_row(setup) for setup in data)

        return (header,) + rows

    def _load_export_module(self):
        _, ext = path.splitext(self._output)
        return import_module('pyexcel_{ext}'.format(ext=ext[1:]))

    def dump(self, results):
        export_module = self._load_export_module()

        spreadsheet_data = OrderedDict(
            (arch.name, self._make_rows(data))
            for arch, data in results.items()
        )

        export_module.save_data(self._output, spreadsheet_data)


class TexWriter:

    _TABLE_TEMPLATE = r'''
\begin{{table}}[H]
  \centering
  \begin{{tabular}}{{{tablespec}}}
{rows}
  \end{{tabular}}
  \caption{{{caption}}}
  \label{{{label}}}
\end{{table}}
'''[1:]                         # Remove first newline.

    def __init__(self, output, caption, label, columns):
        self._output = output
        self._caption = caption
        self._label = label
        self._columns = columns

    def _pad_cell(self, value, padding, alignment):
        return '{value:{alignment}{width}}'.format(
            value=value,
            width=padding,
            alignment=alignment
        )

    def _formatter(self, fmt):
        return lambda s: r'\{fmt}{{{s}}}'.format(fmt=fmt, s=s)

    def _format_header(self):
        formats = defaultdict(
            lambda: str,
            compiler_options=self._formatter('texttt')
        )

        formatted = {
            column: formats[column](caption)
            for column, caption in self._columns.items()
        }

        embolden = self._formatter('textbf')

        return {
            column: embolden(caption) for column, caption in formatted.items()
        }

    def _format_cells(self, setup):
        smallcaps = self._formatter('textsc')
        teletype = self._formatter('texttt')

        formats = defaultdict(
            lambda: str,
            cipher_name=smallcaps,
            version=teletype,
            compiler_options=teletype
        )

        return {
            col: formats[col](setup[col]) for col in self._columns
        }

    def _alignment(self, column):
        if column in METRICS:
            return '>'
        return '<'

    def _pad_row_cells(self, row, paddings):
        return (
            self._pad_cell(row[col], paddings[col], self._alignment(col))
            for col in self._columns
        )

    def _compute_column_padding(self, rows, column):
        return max(len(row[column]) for row in rows)

    def _make_padded_rows(self, data):
        header = self._format_header()
        rows = (header,) + tuple(self._format_cells(setup) for setup in data)

        paddings = {
            column: self._compute_column_padding(rows, column)
            for column in self._columns
        }

        return (
            self._pad_row_cells(row, paddings)
            for row in rows
        )

    def _format_row(self, row):
        return '      ' + ' & '.join(row) + r' \\ \hline'

    def _format_rows(self, data):
        return '\n'.join(
            self._format_row(row) for row in self._make_padded_rows(data)
        )

    def _make_tablespec(self):
        columns = set(self._columns)
        context_nb = len(columns & set(_CONTEXT))
        metrics_nb = len(columns & set(METRICS))

        return '{context}||{metrics}'.format(
            context='|'.join('l'*context_nb),
            metrics='|'.join('r'*metrics_nb)
        )

    def _make_table(self, architecture, data):
        return self._TABLE_TEMPLATE.format(
            rows=self._format_rows(data),
            caption=self._caption.format(arch=architecture.name),
            label=self._label.format(arch=architecture.codename.lower()),
            tablespec=self._make_tablespec()
        )

    def dump(self, results):
        tables = (
            self._make_table(arch, data)
            for arch, data in results.items()
        )

        with open(self._output, 'w') as output:
            output.write('\n'.join(tables))


class HtmlWriter:

    _TABLE_TEMPLATE = '''\
<table>
<caption>{caption}<span data-label="{label}"></span></caption>
<thead>
{header}
</thead>
<tbody>
{body}
</tbody>
</table>
'''

    def __init__(self, output, caption, label, columns):
        self._output = output
        self._caption = caption
        self._label = label
        self._columns = columns

    def _block(self, tag, content, attributes=None, oneline=False):
        if attributes is None:
            start = '<{t}>'.format(t=tag)
        else:
            start = '<{t} {a}>'.format(t=tag, a=attributes)

        end = '</{t}>'.format(t=tag)

        if oneline:
            return start+content+end

        return '\n'.join((start, content, end))

    def _tag_maker(self, tag, attributes=None):
        return lambda content: self._block(
            tag, content, attributes, oneline=True
        )

    def _format_header(self):
        formats = defaultdict(
            lambda: str,
            compiler_options=self._tag_maker('code')
        )

        formatted = (
            formats[column](caption)
            for column, caption in self._columns.items()
        )

        align = self._tag_maker('th', 'align="center"')

        cells = (align(caption) for caption in formatted)

        return self._block(
            'tr', '\n'.join(cells),
            'class="header" style="text-align: center!important"'
        )

    def _format_row(self, setup, n):
        parities = ('even', 'odd')
        row_class = 'class="{parity}"'.format(parity=parities[n%2])

        smallcaps = self._tag_maker('span', 'style="font-variant: small-caps;"')
        code = self._tag_maker('code')

        formats = defaultdict(
            lambda: str,
            cipher_name=smallcaps,
            version=code,
            compiler_options=code
        )

        cells_content = (formats[c](setup[c]) for c in self._columns)
        cells = tuple(
            self._block('td', cell, 'align="center"', oneline=True)
            for cell in cells_content
        )

        return self._block('tr', '\n'.join(cells), row_class)

    def _format_body(self, setups):
        return '\n'.join(
            self._format_row(s, n) for n, s in enumerate(setups, start=1)
        )

    def _make_table(self, architecture, data):
        return self._TABLE_TEMPLATE.format(
            header=self._format_header(),
            body=self._format_body(data),
            caption=self._caption.format(arch=architecture.name),
            label='table:bench-soft-{arch}'.format(arch=architecture.codename.lower())
        )

    def dump(self, results):
        tables = (
            self._make_table(arch, data)
            for arch, data in results.items()
        )

        with open(self._output, 'w') as output:
            output.write('\n'.join(tables))


class ConsoleWriter:

    _ROW_HEADER_TEMPLATE = '{cipher_name} ({version}, {compiler_options}):'
    _ROW_TEMPLATE = '{header:<{header_width}} {code_size:>{code_size_width}} {code_ram:>{code_ram_width}} {code_time:>{code_time_width}}'

    def _max_value_width(self, metric, setups):
        return max(len(s[metric]) for s in setups)

    def _format_rows(self, data):
        def header(setup):
            return self._ROW_HEADER_TEMPLATE.format_map(setup)

        def values(setup):
            return {m: str(setup[m]) for m in METRICS}

        results = OrderedDict((header(setup), values(setup))
                              for setup in data)

        metrics_widths = {
            m + '_width': self._max_value_width(m, results.values())
            for m in METRICS
        }

        return (
            self._ROW_TEMPLATE.format(
                header=header,
                header_width=max(len(header) for header in results),
                **metrics,
                **metrics_widths
            )
            for header, metrics in results.items()
        )

    def dump(self, results):
        for arch, data in results.items():
            print('On {arch}'.format(arch=arch.codename))
            print('\n'.join(self._format_rows(data)))
            print()


def _pick_column_captions(columns, language):
    return OrderedDict((
        (c, _COLUMN_NAMES[language][c]) for c in columns
    ))


def _make_writer(output_filename, caption, label, info):
    if output_filename is None:
        return ConsoleWriter()

    if output_filename.endswith(('.ods', 'xlsx')):
        return SpreadsheetWriter(output_filename, info)

    if output_filename.endswith('.tex'):
        return TexWriter(output_filename, caption, label, info)

    if output_filename.endswith('.html'):
        return HtmlWriter(output_filename, caption, label, info)

    raise ValueError('{f}: unsupported extension'.format(f=output_filename))


def _main(arguments):
    with open(arguments.results) as results_file:
        raw_results = json.load(results_file)['data']

    results_by_arch = _group_setups(raw_results, arguments.sort_by,
                                    arguments.filter)

    columns = _pick_column_captions(arguments.info, arguments.language)

    writer = _make_writer(arguments.output, arguments.table_caption,
                          arguments.table_label, columns)

    writer.dump(results_by_arch)


if __name__ == '__main__':
    _main(_parse_arguments())
