#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-3.0-or-later
# SPDX-FileCopyrightText: 2019 Airbus Cybersecurity SAS

from argparse import ArgumentParser, ArgumentTypeError
from collections import OrderedDict, namedtuple
import json

import git
from git.exc import InvalidGitRepositoryError

from felics import ARCHITECTURES
from felics.analysis import comparison


METRICS = ('code_size', 'code_ram', 'code_time')
_ARCHS_BY_NAME = {a.codename: a for a in ARCHITECTURES}


Results = namedtuple('Results', ('commit', 'branch', 'data', 'filename'))
ResultsKey = namedtuple(
    'ResultsKey', ('architecture', 'compiler_options', 'cipher_name', 'version')
)


def _parse_architectures(argument):
    archs = set(argument.split(','))

    unknown = archs-set(_ARCHS_BY_NAME)
    if unknown:
        raise ArgumentTypeError('Unknown platforms: {}'.format(', '.join(unknown)))

    return archs


def _parse_arguments():
    parser = ArgumentParser()
    parser.add_argument('file1')
    parser.add_argument('file2')
    parser.add_argument(
        '--threshold', default=0.01, type=float,
        help='hide difference when abs(new-old)/old < THRESHOLD'
    )
    parser.add_argument(
        '--archs', default=set(_ARCHS_BY_NAME), type=_parse_architectures,
        help='only consider those architectures'
    )
    return parser.parse_args()


def _make_key(data):
    return ResultsKey._make(
        data[k] for k in ResultsKey._fields
    )


def _load_file(filename, architectures):
    with open(filename) as f:
        results = json.load(f)

    grouped = OrderedDict((a.codename, {})
                          for a in ARCHITECTURES
                          if a.codename in architectures)

    for item in results['data']:
        arch = item['architecture']

        if arch not in grouped:
            continue

        grouped[arch][_make_key(item)] = item

    return Results(results['commit'], results['branch'], grouped, filename)


def _format_metrics(diffs):
    return '\n'.join(
        '    {m}: {d}'.format(m=m, d=diffs[m])
        for m in sorted(diffs, key=METRICS.index)
    )


def _format_revision(setup):
    try:
        repo = git.Repo(search_parent_directories=True)
        summary = repo.git.show(setup.commit, oneline=True, no_patch=True)
        description = '({s.branch}) {summary}'.format(
            s=setup, summary=summary
        )

    except InvalidGitRepositoryError:
        description = '{s.commit} ({s.branch})'.format(s=setup)

    return '\n'.join((
        '\t'+setup.filename,
        '\t'+description
    ))


def _format_header(old, new, threshold):
    return '''Comparing
{old}
against
{new}

(tolerance: {t:.2%})
'''.format(old=_format_revision(old), new=_format_revision(new), t=threshold)


def _format_ratios(setups1, setups2, threshold):
    header = '{cipher_name} (v{version} with {compiler_options})\n'

    for setup in sorted(setups1):
        if setup not in setups2:
            continue

        diffs = comparison.format_differences(setups1[setup], setups2[setup])

        if not diffs:
            continue

        yield header.format_map(setup._asdict())+_format_metrics(diffs)


def _arch_table(arch, lines):
    return '\n\n'.join((arch, '\n\n'.join(lines))) + '\n'


def _format_differences(data1, data2, threshold):
    ratios_by_arch = (
        (arch, tuple(_format_ratios(data1[arch], data2[arch], threshold)))
        for arch in data1
    )

    return '\n'.join(
        _arch_table(arch, ratios) for arch, ratios in ratios_by_arch if ratios
    )


def _arch_key(setup):
    key = list(setup)
    arch = _ARCHS_BY_NAME[key[0]]
    key[0] = ARCHITECTURES.index(arch)
    return key


def _find_absent_setups(data1, data2):
    '''Return a list of setups present in data1 and absent in data2.'''
    setups1 = {s for setups in data1.values() for s in setups}
    setups2 = {s for setups in data2.values() for s in setups}

    return sorted(setups1-setups2, key=_arch_key)


def _main():
    arguments = _parse_arguments()
    file1 = _load_file(arguments.file1, arguments.archs)
    file2 = _load_file(arguments.file2, arguments.archs)

    print(_format_header(file1, file2, arguments.threshold))
    print(_format_differences(file1.data, file2.data, arguments.threshold))

    skipped = _find_absent_setups(file1.data, file2.data)
    if skipped:
        print('Setups not found in {f2}:'.format(f2=arguments.file2))
        print('\n'.join(
            '    {cipher_name} on {architecture} (v{version} with {compiler_options})'.format_map(setup._asdict())
            for setup in skipped
        ))


if __name__ == '__main__':
    _main()
