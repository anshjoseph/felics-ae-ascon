#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-3.0-or-later
# SPDX-FileCopyrightText: 2019 Airbus Cybersecurity SAS

from argparse import ArgumentParser, ArgumentTypeError
from collections import namedtuple
import json

import git
from git.exc import InvalidGitRepositoryError

from felics import ARCHITECTURES, ARCHITECTURES_BY_NAME
from felics.analysis import comparison


Results = namedtuple('Results', ('commit', 'branch', 'data', 'filename'))


def _parse_architectures(argument):
    archs = {ARCHITECTURES_BY_NAME[a] for a in argument.split(',')}

    unknown = archs-set(ARCHITECTURES)
    if unknown:
        raise ArgumentTypeError('Unknown platforms: {}'.format(', '.join(unknown)))

    return archs


def _option_filter(argument):
    if argument is None:
        return lambda _: True

    options = set(argument.split(';'))
    return lambda opt: opt in options


def _parse_arguments():
    parser = ArgumentParser()
    parser.add_argument('file1')
    parser.add_argument('file2')
    parser.add_argument(
        '--threshold', default=0.01, type=float,
        help='hide difference when abs(new-old)/old < THRESHOLD'
    )
    parser.add_argument(
        '--archs', default=ARCHITECTURES, type=_parse_architectures,
        help='only consider those architectures'
    )
    parser.add_argument(
        '--options', default=_option_filter(None), type=_option_filter,
        help='only consider those compiler options (semicolon-separated)'
    )
    return parser.parse_args()


def _load_file(filename, architectures, option_filter):
    with open(filename) as f:
        results = json.load(f)

    setup_keys = ('architecture', 'compiler_options', 'cipher_name', 'version')

    setups = {
        comparison.setup_key(setup, setup_keys): setup
        for setup in results['data']
        if (ARCHITECTURES_BY_NAME[setup['architecture']] in architectures
            and option_filter(setup['compiler_options']))
    }

    return Results(results['commit'], results['branch'], setups, filename)


def _format_revision(setup):
    try:
        repo = git.Repo(search_parent_directories=True)
        summary = repo.git.show(setup.commit, oneline=True, no_patch=True)
        description = '({s.branch}) {summary}'.format(
            s=setup, summary=summary
        )

    except InvalidGitRepositoryError:
        description = '{s.commit} ({s.branch})'.format(s=setup)

    return '\n'.join((
        '\t'+setup.filename,
        '\t'+description
    ))


def _format_header(old, new, threshold):
    return '''Comparing
{old}
against
{new}

(tolerance: {t:.2%})
'''.format(old=_format_revision(old), new=_format_revision(new), t=threshold)


def _format_differences(setups1, setups2, threshold):
    pairs = (
        (setups1[s], setups2[s])
        for s in sorted(setups1)
        if s in setups2
    )
    setup_fmt = '{cipher_name} (v{version} with {compiler_options})'
    return comparison.format_differences(pairs, setup_fmt, threshold)


def _check_skipped_setups(data1, data2):
    setup_fmt = '{cipher_name} on {architecture} (v{version} with {compiler_options})'

    return tuple(
        setup_fmt.format_map(setup._asdict())
        for setup in sorted(set(data1)-set(data2))
    )


def _main():
    arguments = _parse_arguments()
    file1 = _load_file(arguments.file1, arguments.archs, arguments.options)
    file2 = _load_file(arguments.file2, arguments.archs, arguments.options)

    print(_format_header(file1, file2, arguments.threshold))
    print(_format_differences(file1.data, file2.data, arguments.threshold))

    skipped = _check_skipped_setups(file1.data, file2.data)
    if skipped:
        print('Setups not found in {f2}:'.format(f2=arguments.file2))
        print('\n'.join(skipped))


if __name__ == '__main__':
    _main()
