#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-3.0-or-later
# SPDX-FileCopyrightText: 2019 Airbus Cybersecurity SAS

from argparse import ArgumentParser, ArgumentTypeError
from collections import OrderedDict, namedtuple
import json

import git
from git.exc import InvalidGitRepositoryError

from felics import ARCHITECTURES
from felics.analysis import comparison


Results = namedtuple('Results', ('commit', 'branch', 'data', 'filename'))

METRICS = ('code_size', 'code_ram', 'code_time')
_ARCHS_BY_NAME = {a.codename: a for a in ARCHITECTURES}


def _parse_architectures(argument):
    archs = set(argument.split(','))

    unknown = archs-set(_ARCHS_BY_NAME)
    if unknown:
        raise ArgumentTypeError('Unknown platforms: {}'.format(', '.join(unknown)))

    return archs


def _parse_arguments():
    parser = ArgumentParser()
    parser.add_argument('file1')
    parser.add_argument('file2')
    parser.add_argument(
        '--threshold', default=0.01, type=float,
        help='hide difference when abs(new-old)/old < THRESHOLD'
    )
    parser.add_argument(
        '--archs', default=set(_ARCHS_BY_NAME), type=_parse_architectures,
        help='only consider those architectures'
    )
    return parser.parse_args()


def _make_key(data):
    return (
        data['compiler_options'],
        data['cipher_name'],
        data['version']
    )


def _load_file(filename, architectures):
    with open(filename) as f:
        results = json.load(f)

    grouped = OrderedDict((a.codename, {})
                          for a in ARCHITECTURES
                          if a.codename in architectures)

    for item in results['data']:
        arch = item['architecture']

        if arch not in grouped:
            continue

        grouped[arch][_make_key(item)] = item

    return Results(results['commit'], results['branch'], grouped, filename)


def _show_differences(differences, data1, data2):
    for metric in METRICS:      # Show them in the "canonical" order.
        if metric not in differences:
            continue

        diff = comparison.format(differences[metric], data1[metric], data2[metric])

        print('\t{metric}: {diff}'.format(metric=metric, diff=diff))


def _format_revision(setup):
    try:
        repo = git.Repo(search_parent_directories=True)
        summary = repo.git.show(setup.commit, oneline=True, no_patch=True)
        description = '({s.branch}) {summary}'.format(
            s=setup, summary=summary
        )

    except InvalidGitRepositoryError:
        description = '{s.commit} ({s.branch})'.format(s=setup)

    return '\n'.join((
        '\t'+setup.filename,
        '\t'+description
    ))


def _print_header(old, new, threshold):
    header = '''Comparing
{old}
against
{new}

(tolerance: {t:.2%})
'''.format(old=_format_revision(old), new=_format_revision(new), t=threshold)

    print(header)


def _main():
    arguments = _parse_arguments()
    file1 = _load_file(arguments.file1, arguments.archs)
    file2 = _load_file(arguments.file2, arguments.archs)

    _print_header(file1, file2, arguments.threshold)

    SETUP_TEMPLATE = ('{cipher_name} on {architecture} '
                      '(v{version} with {compiler_options})')

    skipped = []

    for arch, results1 in file1.data.items():
        results2 = file2.data[arch]

        for setup, data1 in sorted(results1.items()):
            formatted_setup = SETUP_TEMPLATE.format_map(data1)

            if setup not in results2:
                skipped.append(formatted_setup)
                continue

            data2 = results2[setup]

            differences = comparison.compute_differences(data1, data2, arguments.threshold)

            if not differences:
                continue

            print(formatted_setup)

            _show_differences(differences, data1, data2)

            print()

    if skipped:
        print('Setups not found in {f2}:'.format(f2=arguments.file2))
        print('\n'.join('\t'+setup for setup in skipped))


if __name__ == '__main__':
    _main()
