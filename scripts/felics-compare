#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-3.0-or-later
# SPDX-FileCopyrightText: 2019 Airbus Cybersecurity SAS

from argparse import ArgumentParser, ArgumentTypeError
from collections import defaultdict, namedtuple
import json

import git
from git.exc import InvalidGitRepositoryError

from felics import ARCHITECTURES
from felics.analysis import comparison


_ARCHS_BY_NAME = {a.codename: a for a in ARCHITECTURES}


Results = namedtuple('Results', ('commit', 'branch', 'data', 'filename'))
ResultsKey = namedtuple(
    'ResultsKey', ('architecture', 'compiler_options', 'cipher_name', 'version')
)


def _parse_architectures(argument):
    archs = {_ARCHS_BY_NAME[a] for a in argument.split(',')}

    unknown = archs-set(ARCHITECTURES)
    if unknown:
        raise ArgumentTypeError('Unknown platforms: {}'.format(', '.join(unknown)))

    return archs


def _parse_arguments():
    parser = ArgumentParser()
    parser.add_argument('file1')
    parser.add_argument('file2')
    parser.add_argument(
        '--threshold', default=0.01, type=float,
        help='hide difference when abs(new-old)/old < THRESHOLD'
    )
    parser.add_argument(
        '--archs', default=ARCHITECTURES, type=_parse_architectures,
        help='only consider those architectures'
    )
    return parser.parse_args()


def _make_key(data):
    return ResultsKey._make(
        data[k] for k in ResultsKey._fields
    )


def _load_file(filename, architectures):
    with open(filename) as f:
        results = json.load(f)

    grouped = defaultdict(lambda: defaultdict(dict))

    for item in results['data']:
        arch = _ARCHS_BY_NAME[item['architecture']]

        if arch not in architectures:
            continue

        grouped[arch][_make_key(item)] = item

    return Results(results['commit'], results['branch'], grouped, filename)


def _format_revision(setup):
    try:
        repo = git.Repo(search_parent_directories=True)
        summary = repo.git.show(setup.commit, oneline=True, no_patch=True)
        description = '({s.branch}) {summary}'.format(
            s=setup, summary=summary
        )

    except InvalidGitRepositoryError:
        description = '{s.commit} ({s.branch})'.format(s=setup)

    return '\n'.join((
        '\t'+setup.filename,
        '\t'+description
    ))


def _format_header(old, new, threshold):
    return '''Comparing
{old}
against
{new}

(tolerance: {t:.2%})
'''.format(old=_format_revision(old), new=_format_revision(new), t=threshold)


def _generate_pairs(setups1, setups2):
    return (
        (setups1[setup], setups2[setup])
        for setup in sorted(setups1)
        if setup in setups2
    )


def _format_differences(data1, data2, threshold):
    setup_pairs = {
        arch: _generate_pairs(data1[arch], data2[arch])
        for arch in data1
    }

    setup_fmt = '{cipher_name} (v{version} with {compiler_options})'

    diffs = {
        arch: comparison.format_differences(pairs, setup_fmt, threshold)
        for arch, pairs in setup_pairs.items()
    }

    tables = (
        '\n\n'.join((arch.codename, '\n\n'.join(diffs[arch]))) + '\n'
        for arch in sorted(diffs, key=ARCHITECTURES.index)
    )

    return '\n'.join(tables)


def _find_absent_setups(data1, data2):
    '''Return a list of setups present in data1 and absent in data2.'''
    setups1 = {s for setups in data1.values() for s in setups}
    setups2 = {s for setups in data2.values() for s in setups}

    return sorted(setups1-setups2)


def _main():
    arguments = _parse_arguments()
    file1 = _load_file(arguments.file1, arguments.archs)
    file2 = _load_file(arguments.file2, arguments.archs)

    print(_format_header(file1, file2, arguments.threshold))
    print(_format_differences(file1.data, file2.data, arguments.threshold))

    skipped = _find_absent_setups(file1.data, file2.data)
    if skipped:
        print('Setups not found in {f2}:'.format(f2=arguments.file2))
        print('\n'.join(
            '    {cipher_name} on {architecture} (v{version} with {compiler_options})'.format_map(setup._asdict())
            for setup in skipped
        ))


if __name__ == '__main__':
    _main()
