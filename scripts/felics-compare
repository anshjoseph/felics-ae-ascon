#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-3.0-or-later
# SPDX-FileCopyrightText: 2019 Airbus Cybersecurity SAS

from argparse import ArgumentParser, ArgumentTypeError
from collections import namedtuple
import json

import git
from git.exc import InvalidGitRepositoryError

from felics import ARCHITECTURES
from felics.analysis import comparison


Results = namedtuple('Results', ('commit', 'branch', 'data', 'filename'))

METRICS = ('code_size', 'code_ram', 'code_time')
_ARCHS_BY_NAME = {a.codename: a for a in ARCHITECTURES}


def _parse_architectures(argument):
    archs = set(argument.split(','))

    unknown = archs-set(_ARCHS_BY_NAME)
    if unknown:
        raise ArgumentTypeError('Unknown platforms: {}'.format(', '.join(unknown)))

    return archs


def _parse_arguments():
    parser = ArgumentParser()
    parser.add_argument('file1')
    parser.add_argument('file2')
    parser.add_argument(
        '--threshold', default=0.01, type=float,
        help='hide difference when abs(new-old)/old < THRESHOLD'
    )
    parser.add_argument(
        '--archs', default=set(_ARCHS_BY_NAME), type=_parse_architectures,
        help='only consider those architectures'
    )
    return parser.parse_args()


def _make_key(data):
    arch = _ARCHS_BY_NAME[data['architecture']]

    return (
        arch.size,
        arch.codename,
        data['compiler_options'],
        data['cipher_name'],
        data['version']
    )


def _load_file(filename, architectures):
    with open(filename) as f:
        results = json.load(f)

    data = {
        _make_key(item): item
        for item in results['data']
        if item['architecture'] in architectures
    }

    return Results(results['commit'], results['branch'], data, filename)


def _show_differences(differences, data1, data2):
    for metric in METRICS:      # Show them in the "canonical" order.
        if metric not in differences:
            continue

        diff = comparison.format(differences[metric], data1[metric], data2[metric])

        print('\t{metric}: {diff}'.format(metric=metric, diff=diff))


def _compute_differences(threshold, data1, data2):
    differences = ((m, (data2[m] - data1[m]) / data1[m]) for m in METRICS)

    return {
        m: relative_diff
        for m, relative_diff in differences
        if abs(relative_diff) > threshold
    }


def _format_revision(setup):
    try:
        repo = git.Repo(search_parent_directories=True)
        summary = repo.git.show(setup.commit, oneline=True, no_patch=True)
        description = '({s.branch}) {summary}'.format(
            s=setup, summary=summary
        )

    except InvalidGitRepositoryError:
        description = '{s.commit} ({s.branch})'.format(s=setup)

    return '\n'.join((
        '\t'+setup.filename,
        '\t'+description
    ))


def _print_header(old, new, threshold):
    header = '''Comparing
{old}
against
{new}

(tolerance: {t:.2%})
'''.format(old=_format_revision(old), new=_format_revision(new), t=threshold)

    print(header)


def _main():
    arguments = _parse_arguments()
    file1 = _load_file(arguments.file1, arguments.archs)
    file2 = _load_file(arguments.file2, arguments.archs)

    _print_header(file1, file2, arguments.threshold)

    SETUP_TEMPLATE = ('{cipher_name} on {architecture} '
                      '(v{version} with {compiler_options})')

    skipped = []

    for setup, data1 in sorted(file1.data.items()):

        formatted_setup = SETUP_TEMPLATE.format_map(data1)

        if setup not in file2.data:
            skipped.append(formatted_setup)
            continue

        data2 = file2.data[setup]

        differences = _compute_differences(arguments.threshold, data1, data2)

        if not differences:
            continue

        print(formatted_setup)

        _show_differences(differences, data1, data2)

        print()

    if skipped:
        print('Setups not found in {f2}:'.format(f2=arguments.file2))
        print('\n'.join('\t'+setup for setup in skipped))


if __name__ == '__main__':
    _main()
