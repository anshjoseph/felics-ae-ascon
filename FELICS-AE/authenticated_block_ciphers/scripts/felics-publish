#!/usr/bin/env python3

from argparse import ArgumentParser
from collections import defaultdict, OrderedDict
import json
from os import path
import re

import pyexcel_ods
import pyexcel_xlsx


_ARCHITECTURES = OrderedDict((
    ('AVR', 'AVR ATmega128'),
    ('MSP', 'MSP430F1611'),
    ('ARM', 'ARM Cortex-M3'),
    ('PC', 'PC')
))

_CONTEXT = OrderedDict((
    ('cipher_name', ''),
    ('version', 'Version'),
    ('compiler_options', 'Compiler options')
))

_METRICS = OrderedDict((
    ('code_size', 'Size (bytes)'),
    ('code_ram', 'RAM (bytes)'),
    ('code_time', 'Execution time (cycles)')
))

_COLUMNS = OrderedDict(
    (k, v) for d in (_CONTEXT, _METRICS) for k, v in d.items()
)


def _parse_sort_order(argument):
    return argument.split(',')


def _parse_filter(argument):
    patterns = dict(
        subfilter.split('=') for subfilter in argument.split(',')
    )

    def accept_setup(setup):
        return all(
            re.match(pattern, setup[key])
            for key, pattern in patterns.items()
        )

    return accept_setup


def _parse_arguments():
    parser = ArgumentParser()

    parser.add_argument('-o', '--out', dest='output')

    parser.add_argument(
        '-s', '--sort-by', default=('compiler_options', 'cipher_name'),
        type=_parse_sort_order, metavar='KEY[,KEY...]'
    )

    parser.add_argument(
        '-f', '--filter', default=lambda setup: True, type=_parse_filter,
        metavar='KEY=REGEX[,KEY=REGEX...]'
    )

    parser.add_argument(
        '-l', '--table-label', default='table:bench-soft-{arch}'
    )

    parser.add_argument(
        '-c', '--table-caption', default='Performance results on {arch}.'
    )

    parser.add_argument('results', metavar='JSON-RESULTS')

    return parser.parse_args()


def _sort_setups(setups, keys):
    def make_key(setup):
        return tuple(setup[k] for k in keys)

    return sorted(setups, key=make_key)


def _group_setups(setups, sort_keys, predicate):
    setups_by_arch = defaultdict(list)

    for setup in setups:
        if predicate(setup):
            setups_by_arch[setup['architecture']].append(setup)

    return OrderedDict(
        (arch, _sort_setups(setups_by_arch[arch], sort_keys))
        for arch in _ARCHITECTURES
        if arch in setups_by_arch
    )


class SpreadsheetWriter:

    _MODULES = {
        '.xlsx': pyexcel_xlsx,
        '.ods': pyexcel_ods
    }

    def __init__(self, output):
        self._output = output

    def _make_row(self, setup):
        return tuple(setup[c] for c in _COLUMNS)

    def _make_rows(self, data):
        header = tuple(_COLUMNS.values())
        rows = tuple(self._make_row(setup) for setup in data)

        return (header,) + rows

    def dump(self, results):
        spreadsheet_data = OrderedDict(
            (arch, self._make_rows(data))
            for arch, data in results.items()
        )

        _, ext = path.splitext(self._output)
        self._MODULES[ext].save_data(self._output, spreadsheet_data)


class TexWriter:

    _TABLE_TEMPLATE = r'''
\begin{{table}}[H]
  \centering
  \begin{{tabular}}{{l|l|l||r|r|r}}
{rows}
  \end{{tabular}}
  \caption{{{caption}}}
  \label{{{label}}}
\end{{table}}
'''[1:]                         # Remove first newline.

    def __init__(self, output, caption, label):
        self._output = output
        self._caption = caption
        self._label = label

    def _pad_cell(self, value, padding, alignment):
        return '{value:{alignment}{width}}'.format(
            value=value,
            width=padding,
            alignment=alignment
        )

    def _list_header_fields(self):
        def bold(s):
            return r'\textbf{{{s}}}'.format(s=s)

        return tuple(bold(caption) for caption in _COLUMNS.values())

    def _list_row_fields(self, setup):
        def raw(value):
            return str(value)

        def smallcap(value):
            return r'\textsc{{{}}}'.format(value)

        def texttt(value):
            return r'\texttt{{{}}}'.format(value)

        formatters = defaultdict(
            lambda: raw,
            cipher_name=smallcap,
            version=texttt,
            compiler_options=texttt
        )

        return tuple(formatters[c](setup[c]) for c in _COLUMNS)

    def _alignment(self, column_name):
        if column_name in _METRICS:
            return '>'
        return '<'

    def _pad_row_cells(self, row, paddings):
        column_names = tuple(_COLUMNS)

        return (
            self._pad_cell(cell, paddings[c], self._alignment(column_names[c]))
            for c, cell in enumerate(row)
        )

    def _compute_column_padding(self, rows, column):
        return max(len(row[column]) for row in rows)

    def _make_padded_rows(self, data):
        header = self._list_header_fields()
        rows = (header,) + tuple(self._list_row_fields(setup) for setup in data)

        columns_nb = len(header)
        paddings = tuple(
            self._compute_column_padding(rows, c) for c in range(columns_nb)
        )

        return (
            self._pad_row_cells(row, paddings)
            for row in rows
        )

    def _format_row(self, row):
        return '      ' + ' & '.join(row) + r' \\ \hline'

    def _format_rows(self, data):
        return '\n'.join(
            self._format_row(row) for row in self._make_padded_rows(data)
        )

    def _make_table(self, architecture, data):
        return self._TABLE_TEMPLATE.format(
            rows=self._format_rows(data),
            caption=self._caption.format(arch=_ARCHITECTURES[architecture]),
            label=self._label.format(arch=architecture.lower())
        )

    def dump(self, results):
        tables = (
            self._make_table(arch, data)
            for arch, data in results.items()
        )

        with open(self._output, 'w') as output:
            output.write('\n'.join(tables))


class HtmlWriter:

    _TABLE_TEMPLATE = '''\
<table>
<caption>{caption}<span data-label="{label}"></span></caption>
<thead>
{header}
</thead>
<tbody>
{body}
</tbody>
</table>
'''

    def __init__(self, output, caption, label):
        self._output = output
        self._caption = caption
        self._label = label

    def _block(self, tag, content, attributes=None, oneline=False):
        if attributes is None:
            start = '<{t}>'.format(t=tag)
        else:
            start = '<{t} {a}>'.format(t=tag, a=attributes)

        end = '</{t}>'.format(t=tag)

        if oneline:
            return start+content+end

        return '\n'.join((start, content, end))

    def _format_header(self):
        lines = tuple(
            '<th align="center">{c}</th>'.format(c=value)
            for value in _COLUMNS.values()
        )

        return self._block(
            'tr', '\n'.join(lines),
            'class="header" style="text-align: center!important"'
        )

    def _format_row(self, setup, n):
        parities = ('even', 'odd')
        row_class = 'class="{parity}"'.format(parity=parities[n%2])

        def raw(value):
            return str(value)

        def smallcap(value):
            return self._block(
                'span', value, 'style="font-variant: small-caps;"', oneline=True
            )

        def code(value):
            return self._block('code', value, oneline=True)

        formatters = defaultdict(
            lambda: raw,
            cipher_name=smallcap,
            version=code,
            compiler_options=code
        )

        columns_content = (formatters[c](setup[c]) for c in _COLUMNS)
        columns = tuple(
            self._block('td', content, 'align="center"', oneline=True)
            for content in columns_content
        )

        return self._block('tr', '\n'.join(columns), row_class)

    def _format_body(self, setups):
        return '\n'.join(
            self._format_row(s, n) for n, s in enumerate(setups, start=1)
        )

    def _make_table(self, architecture, data):
        return self._TABLE_TEMPLATE.format(
            header=self._format_header(),
            body=self._format_body(data),
            caption=self._caption.format(arch=_ARCHITECTURES[architecture]),
            label='table:bench-soft-{arch}'.format(arch=architecture.lower())
        )

    def dump(self, results):
        tables = (
            self._make_table(arch, data)
            for arch, data in results.items()
        )

        with open(self._output, 'w') as output:
            output.write('\n'.join(tables))


class ConsoleWriter:

    _ROW_HEADER_TEMPLATE = '{cipher_name} ({version}, {compiler_options}):'
    _ROW_TEMPLATE = '{header:<{header_width}} {code_size:>{code_size_width}} {code_ram:>{code_ram_width}} {code_time:>{code_time_width}}'

    def _max_value_width(self, metric, setups):
        return max(len(s[metric]) for s in setups)

    def _format_rows(self, data):
        def header(setup):
            return self._ROW_HEADER_TEMPLATE.format_map(setup)

        def values(setup):
            return {m: str(setup[m]) for m in _METRICS}

        results = OrderedDict((header(setup), values(setup))
                              for setup in data)

        metrics_widths = {
            m + '_width': self._max_value_width(m, results.values())
            for m in _METRICS
        }

        return (
            self._ROW_TEMPLATE.format(
                header=header,
                header_width=max(len(header) for header in results),
                **metrics,
                **metrics_widths
            )
            for header, metrics in results.items()
        )

    def dump(self, results):
        for arch, data in results.items():
            print('On {arch}'.format(arch=arch))
            print('\n'.join(self._format_rows(data)))
            print()


def _make_writer(output_filename, caption, label):
    if output_filename is None:
        return ConsoleWriter()

    if output_filename.endswith(('.ods', 'xlsx')):
        return SpreadsheetWriter(output_filename)

    if output_filename.endswith('.tex'):
        return TexWriter(output_filename, caption, label)

    if output_filename.endswith('.html'):
        return HtmlWriter(output_filename, caption, label)

    raise ValueError('{f}: unsupported extension'.format(f=output_filename))


if __name__ == '__main__':
    arguments = _parse_arguments()

    with open(arguments.results) as results_file:
        raw_results = json.load(results_file)['data']

    results_by_arch = _group_setups(raw_results, arguments.sort_by,
                                    arguments.filter)

    writer = _make_writer(arguments.output, arguments.table_caption,
                          arguments.table_label)

    writer.dump(results_by_arch)
