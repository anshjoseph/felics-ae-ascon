#!/usr/bin/env python3

from argparse import ArgumentParser
from collections import defaultdict, OrderedDict
import json
import re

import pyexcel_ods


def _parse_arguments():
    parser = ArgumentParser()
    parser.add_argument('-o', '--out', dest='output', required=True)
    parser.add_argument('results')
    return parser.parse_args()


def _sort_by_arch_and_scenario(data):
    sorted_data = defaultdict(list)

    for setup in data:
        key = (setup['architecture'], setup['scenario'])
        sorted_data[key].append(setup)

    return sorted_data


def _convert_to_ods(results, output_filename):
    ods_data = OrderedDict()

    for (arch, scenario), data in results.items():
        sheet_name = '{arch} - scenario {scenario}'.format(arch=arch, scenario=scenario)

        ods_data[sheet_name] = [
            [
                'Designation', 'Language', 'Compiler options', 'Size (bytes)',
                'RAM (bytes)', 'Execution time (cycles)'
            ]
        ]

        ods_data[sheet_name].extend(
            [
                '{cipher_name}-{block_size}-{key_size} v{version}'.format_map(setup),
                setup['language'], setup['compiler_options'],
                setup['code_size'], setup['code_ram'], setup['code_time']
            ]
            for setup in data
        )

    pyexcel_ods.save_data(output_filename, ods_data)


def _make_tex_name(setup):
    name = setup['cipher_name']

    if re.fullmatch('(Lilliput|Deoxys)I+', name):
        name = re.sub('(.*[^I])(I+)', r'\1-\2', name)

    return r'\textsc{{{name}-{blocklen}-{keylen}}}'.format(
        name=name, blocklen=setup['block_size'], keylen=setup['key_size']
    )


def _pad_field(value, index, padding):
    if index == 0:
        return '{field:<{width}}'.format(field=value, width=padding)

    return '{field:>{width}}'.format(field=value, width=padding)


def _make_padded_tex_lines(data):
    header = ['', 'Code size (B)', 'RAM (B)', 'Execution time (cycles)']

    lines = [header] + [
        [
            _make_tex_name(setup), str(setup['code_size']),
            str(setup['code_ram']), str(setup['code_time'])
        ]
        for setup in data
    ]

    fields_nb = len(lines[0])
    max_lengths = [
        max(len(line[i]) for line in lines)
        for i in range(fields_nb)
    ]

    padded_lines = [
        [
            _pad_field(field, i, max_lengths[i])
            for i, field in enumerate(line)
        ]
        for line in lines
    ]

    return padded_lines


def _format_tex_line(line):
    return '      ' + ' & '.join(line) + r' \\ \hline' + '\n'


def _convert_to_tex(results, output_filename):
    with open(output_filename, 'w') as output:

        for (arch, scenario), data in results.items():
            caption = 'Performance results for scenario {scenario} on {arch}'.format(
                arch=arch, scenario=scenario
            )

            header = '''\
\\begin{table}[H]
  \\begin{center}
    \\begin{tabular}{l|r|r|r}
'''
            footer = '''\
    \\end{{tabular}}
    \\caption{{{caption}}}
    \\label{{benchmark_software_{arch}}}
  \\end{{center}}
\\end{{table}}

'''.format(arch=arch.lower(), caption=caption)

            output.write(header)
            output.writelines(
                _format_tex_line(line) for line in _make_padded_tex_lines(data)
            )
            output.write(footer)


def _convert(results, output_filename):
    if output_filename.endswith('.ods'):
        _convert_to_ods(results, output_filename)
    elif output_filename.endswith('.tex'):
        _convert_to_tex(results, output_filename)
    else:
        raise ValueError('{f}: unsupported extension'.format(f=output_filename))


if __name__ == '__main__':
    arguments = _parse_arguments()

    with open(arguments.results) as results_file:
        raw_results = json.load(results_file)

    sorted_results = _sort_by_arch_and_scenario(raw_results)

    _convert(sorted_results, arguments.output)
