#!/usr/bin/env python3

from argparse import ArgumentParser
from collections import defaultdict, OrderedDict
import json
from os import path

import pyexcel_ods
import pyexcel_xlsx


_ARCHITECTURES = ('AVR', 'MSP', 'ARM', 'PC')
_METRICS = ('code_size', 'code_ram', 'code_time')


def _parse_sort_order(argument):
    return argument.split(',')


def _parse_arguments():
    parser = ArgumentParser()

    parser.add_argument('-o', '--out', dest='output')

    parser.add_argument(
        '-s', '--sort-by', default=('compiler_options', 'cipher_name'),
        type=_parse_sort_order
    )

    parser.add_argument('results')

    return parser.parse_args()


def _sort_setups(setups, keys):
    def make_key(setup):
        return tuple(setup[k] for k in keys)

    return sorted(setups, key=make_key)


def _order_setups(setups, sort_keys):
    setups_by_arch = defaultdict(list)

    for setup in setups:
        setups_by_arch[setup['architecture']].append(setup)

    return OrderedDict(
        (arch, _sort_setups(setups_by_arch[arch], sort_keys))
        for arch in _ARCHITECTURES
        if arch in setups_by_arch
    )


class SpreadsheetWriter:

    _MODULES = {
        '.xlsx': pyexcel_xlsx,
        '.ods': pyexcel_ods
    }

    _SHEET_COLUMNS = OrderedDict((
        ('cipher_name', 'Designation'),
        ('version', 'Version'),
        ('compiler_options', 'Compiler options'),
        ('code_size', 'Size (bytes)'),
        ('code_ram', 'RAM (bytes)'),
        ('code_time', 'Execution time (cycles)')
    ))

    def __init__(self, output):
        self._output = output

    def _make_row(self, setup):
        return tuple(setup[c] for c in self._SHEET_COLUMNS)

    def _make_rows(self, data):
        header = tuple(self._SHEET_COLUMNS.values())
        rows = tuple(self._make_row(setup) for setup in data)

        return (header,) + rows

    def dump(self, results):
        spreadsheet_data = OrderedDict(
            (arch, self._make_rows(data))
            for arch, data in results.items()
        )

        _, ext = path.splitext(self._output)
        self._MODULES[ext].save_data(self._output, spreadsheet_data)


class TexWriter:

    _TABLE_TEMPLATE = r'''
\begin{{table}}[H]
  \centering
  \begin{{tabular}}{{l|l|l||r|r|r}}
{rows}
  \end{{tabular}}
  \caption{{{caption}}}
  \label{{table:bench-soft-{arch}}}
\end{{table}}
'''[1:]                         # Remove first newline.

    _COLUMNS = OrderedDict((
        ('cipher_name', ''),
        ('version', 'Version'),
        ('compiler_options', r'\texttt{CFLAGS}'),
        ('code_size', 'Code size (B)'),
        ('code_ram', 'RAM (B)'),
        ('code_time', 'Execution time (cycles)')
    ))

    _PLATFORM_NAMES = {
        'AVR': 'AVR ATmega128',
        'MSP': 'MSP430F1611',
        'ARM': 'ARM Cortex-M3',
        'PC': 'PC'
    }

    def __init__(self, output):
        self._output = output

    def _pad_cell(self, value, padding, alignment):
        return '{value:{alignment}{width}}'.format(
            value=value,
            width=padding,
            alignment=alignment
        )

    def _list_header_fields(self):
        def bold(s):
            return r'\textbf{{{s}}}'.format(s=s)

        return tuple(bold(caption) for caption in self._COLUMNS.values())

    def _list_row_fields(self, setup):
        def raw(value):
            return str(value)

        def smallcap(value):
            return r'\textsc{{{}}}'.format(value)

        def texttt(value):
            return r'\texttt{{{}}}'.format(value)

        formatters = defaultdict(
            lambda: raw,
            cipher_name=smallcap,
            version=texttt,
            compiler_options=texttt
        )

        return tuple(formatters[c](setup[c]) for c in self._COLUMNS)

    def _alignment(self, column_name):
        if column_name in _METRICS:
            return '>'
        return '<'

    def _pad_row_cells(self, row, paddings):
        column_names = tuple(self._COLUMNS)

        return (
            self._pad_cell(cell, paddings[c], self._alignment(column_names[c]))
            for c, cell in enumerate(row)
        )

    def _compute_column_padding(self, rows, column):
        return max(len(row[column]) for row in rows)

    def _make_padded_rows(self, data):
        header = self._list_header_fields()
        rows = (header,) + tuple(self._list_row_fields(setup) for setup in data)

        columns_nb = len(header)
        paddings = tuple(
            self._compute_column_padding(rows, c) for c in range(columns_nb)
        )

        return (
            self._pad_row_cells(row, paddings)
            for row in rows
        )

    def _format_row(self, row):
        return '      ' + ' & '.join(row) + r' \\ \hline'

    def _format_rows(self, data):
        return '\n'.join(
            self._format_row(row) for row in self._make_padded_rows(data)
        )

    def _make_table(self, architecture, data):
        return self._TABLE_TEMPLATE.format(
            rows=self._format_rows(data),
            arch=architecture.lower(),
            caption='Performance results on {arch}.'.format(
                arch=self._PLATFORM_NAMES[architecture]
            )
        )

    def dump(self, results):
        tables = (
            self._make_table(arch, data)
            for arch, data in results.items()
        )

        with open(self._output, 'w') as output:
            output.write('\n'.join(tables))


class ConsoleWriter:

    _ROW_HEADER_TEMPLATE = '{cipher_name} ({version}, {compiler_options}):'
    _ROW_TEMPLATE = '{header:<{header_width}} {code_size:>{code_size_width}} {code_ram:>{code_ram_width}} {code_time:>{code_time_width}}'

    def _max_value_width(self, metric, setups):
        return max(len(s[metric]) for s in setups)

    def _format_rows(self, data):
        def header(setup):
            return self._ROW_HEADER_TEMPLATE.format_map(setup)

        def values(setup):
            return {m: str(setup[m]) for m in _METRICS}

        results = OrderedDict((header(setup), values(setup))
                              for setup in data)

        metrics_widths = {
            m + '_width': self._max_value_width(m, results.values())
            for m in _METRICS
        }

        return (
            self._ROW_TEMPLATE.format(
                header=header,
                header_width=max(len(header) for header in results),
                **metrics,
                **metrics_widths
            )
            for header, metrics in results.items()
        )

    def dump(self, results):
        for arch, data in results.items():
            print('On {arch}'.format(arch=arch))
            print('\n'.join(self._format_rows(data)))
            print()


def _make_writer(output_filename):
    if output_filename is None:
        return ConsoleWriter()
    if output_filename.endswith(('.ods', 'xlsx')):
        return SpreadsheetWriter(output_filename)
    if output_filename.endswith('.tex'):
        return TexWriter(output_filename)

    raise ValueError('{f}: unsupported extension'.format(f=output_filename))


if __name__ == '__main__':
    arguments = _parse_arguments()

    with open(arguments.results) as results_file:
        raw_results = json.load(results_file)['data']

    results_by_arch = _order_setups(raw_results, arguments.sort_by)

    writer = _make_writer(arguments.output)
    writer.dump(results_by_arch)
