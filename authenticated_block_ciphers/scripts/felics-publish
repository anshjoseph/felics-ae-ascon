#!/usr/bin/env python3

from argparse import ArgumentParser
from collections import defaultdict, OrderedDict
import json
from os import path
import re

import pyexcel_ods
import pyexcel_xlsx


def _parse_arguments():
    parser = ArgumentParser()
    parser.add_argument('-o', '--out', dest='output')
    parser.add_argument('results')
    return parser.parse_args()


def _sort_by_architecture(data):
    sorted_data = defaultdict(list)

    for setup in data:
        sorted_data[setup['architecture']].append(setup)

    widths = {'AVR': 8, 'MSP': 16, 'ARM': 32, 'PC': 64}

    return OrderedDict(
        (key, sorted_data[key]) for key in sorted(sorted_data, key=widths.get)
    )


class SpreadsheetWriter:

    _MODULES = {
        '.xlsx': pyexcel_xlsx,
        '.ods': pyexcel_ods
    }

    _SHEET_COLUMNS = OrderedDict((
        ('cipher_name', 'Designation'),
        ('key_size', 'Key size (bits)'),
        ('version', 'Version'),
        ('language', 'Language'),
        ('compiler_options', 'Compiler options'),
        ('code_size', 'Size (bytes)'),
        ('code_ram', 'RAM (bytes)'),
        ('code_time', 'Execution time (cycles)')
    ))

    def __init__(self, results, output):
        self._results = results
        self._output = output

    def _make_rows(self, data):
        header = tuple(self._SHEET_COLUMNS.values())
        rows = (tuple(setup[c] for c in self._SHEET_COLUMNS) for setup in data)
        return (header,) + tuple(rows)

    def dump(self):
        spreadsheet_data = OrderedDict(
            (arch, self._make_rows(data))
            for arch, data in self._results.items()
        )

        _, ext = path.splitext(self._output)
        self._MODULES[ext].save_data(self._output, spreadsheet_data)


def _make_tex_name(setup):
    name = setup['cipher_name']

    if re.fullmatch('(Lilliput|Deoxys)I+', name):
        name = re.sub('(.*[^I])(I+)', r'\1-\2', name)

    return r'\textsc{{{name}-{blocklen}-{keylen}}}'.format(
        name=name, blocklen=setup['block_size'], keylen=setup['key_size']
    )


def _pad_field(value, index, padding):
    if index == 0:
        return '{field:<{width}}'.format(field=value, width=padding)

    return '{field:>{width}}'.format(field=value, width=padding)


def _make_padded_tex_lines(data):
    header = ['', 'Code size (B)', 'RAM (B)', 'Execution time (cycles)']

    lines = [header] + [
        [
            _make_tex_name(setup), str(setup['code_size']),
            str(setup['code_ram']), str(setup['code_time'])
        ]
        for setup in data
    ]

    fields_nb = len(lines[0])
    max_lengths = [
        max(len(line[i]) for line in lines)
        for i in range(fields_nb)
    ]

    padded_lines = [
        [
            _pad_field(field, i, max_lengths[i])
            for i, field in enumerate(line)
        ]
        for line in lines
    ]

    return padded_lines


def _format_tex_line(line):
    return '      ' + ' & '.join(line) + r' \\ \hline'


def _generate_tex_rows(data):
    return '\n'.join(
        _format_tex_line(line) for line in _make_padded_tex_lines(data)
    )


_TEX_TABLE_TEMPLATE = r'''
\begin{{table}}[H]
  \begin{{center}}
    \begin{{tabular}}{{l|r|r|r}}
{rows}
    \end{{tabular}}
    \caption{{{caption}}}
    \label{{benchmark_software_{arch}}}
  \end{{center}}
\end{{table}}
'''[1:]                         # Remove first newline.


def _make_tex_table(architecture, data):
    caption = 'Performance results on {arch}'.format(arch=architecture)

    return _TEX_TABLE_TEMPLATE.format(
        rows=_generate_tex_rows(data),
        arch=architecture.lower(),
        caption=caption
    )


def _convert_to_tex(results, output_filename):
    tables = (_make_tex_table(arch, data) for arch, data in results.items())

    with open(output_filename, 'w') as output:
        output.write('\n'.join(tables))


_STDOUT_PREFIX_TEMPLATE = '{cipher_name}-{key_size} ({version}, {compiler_options}):'
_STDOUT_LINE_TEMPLATE = '{prefix:<{prefix_width}} {code_size:>{code_size_width}} {code_ram:>{code_ram_width}} {code_time:>{code_time_width}}'


def _make_line_values(prefix, prefix_width, metrics, metrics_widths):
    return {'prefix': prefix, 'prefix_width': prefix_width, **metrics, **metrics_widths}


def _format_stdout_lines(results):
    metrics = ('code_size', 'code_ram', 'code_time')

    results = OrderedDict((
        (
            _STDOUT_PREFIX_TEMPLATE.format_map(setup),
            {m: setup[m] for m in metrics}
        )
    ) for setup in results)

    metrics_widths = {
        m+'_width': max(len(str(values[m])) for values in results.values())
        for m in metrics
    }

    prefix_width = max(len(p) for p in results)

    return (
        _STDOUT_LINE_TEMPLATE.format_map(
            _make_line_values(prefix, prefix_width, metrics, metrics_widths)
        )
        for prefix, metrics in results.items()
    )


def _dump_to_stdout(results):
    for arch, data in results.items():
        print('On {arch}'.format(arch=arch))
        print('\n'.join(_format_stdout_lines(data)))
        print()


def _convert(results, output_filename):
    if output_filename is None:
        _dump_to_stdout(results)
    elif output_filename.endswith(('.ods', 'xlsx')):
        SpreadsheetWriter(results, output_filename).dump()
    elif output_filename.endswith('.tex'):
        _convert_to_tex(results, output_filename)
    else:
        raise ValueError('{f}: unsupported extension'.format(f=output_filename))


if __name__ == '__main__':
    arguments = _parse_arguments()

    with open(arguments.results) as results_file:
        raw_results = json.load(results_file)['data']

    sorted_results = _sort_by_architecture(raw_results)

    _convert(sorted_results, arguments.output)
