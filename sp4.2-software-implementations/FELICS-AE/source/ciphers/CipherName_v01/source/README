Initial file structure
======================

.									-> CipherName_BlockSizeInBits_KeySizeInBits_v01
├── build							-> Cipher build directory
└── source							-> Cipher source directory
    ├── data_types.h				-> Cipher data types
    ├── decrypt.c					-> Cipher decryption
    ├── encrypt.c					-> Cipher encryption
    ├── implementation.info			-> Cipher implementation information
    └── test_vectors.c				-> Cipher test vectors



Add cipher implementation
=========================

Steps:
	1. Make a copy of "CipherName_BlockSizeInBits_KeySizeInBits_v01" directory 
in "ciphers" directory.

	2. Rename the copy of the directory to follow the pattern 
"CipherName_BlockSizeInBits_KeySizeInBits_v01".
			Example: "LBlock_64_80_v01"
		Note: If you add several implementation for the same cipher (for example
 one optimized for RAM and one optimized for speed) you can increase the 
cipher directory name suffix "_v02", "_v03", etc.
			Example: LBlock_64_80_v02

	3. Add cipher implementation:
		a. Add cipher block size, key size and round keys size in "constants.h".
		
		b. Declare & define the cipher test vectors in "test_vectors.c".

		c. Implement the encryption in "encrypt.c" using the "crypto_aead.h" API.

			Note: To read the value of the round  key use the "READ_ROUND_KEY_*"
("READ_ROUND_KEY_BYTE", "READ_ROUND_KEY_WORD", "READ_ROUND_KEY_DOUBLE_WORD") 
macro. It allows to read the round keys from RAM or Flash/ROM depending on the
 scenario.
			Example:
				uint8_t ramRK[0] = READ_ROUND_KEY_BYTE(roundKey[0]);
				uint16_t ramRK[0] = READ_ROUND_KEY_WORD(roundKey[0]);
				uint32_t ramRK[0] = READ_ROUND_KEY_DOUBLE_WORD(roundKey[0]);
			Note: To read data types based on "RAM_DATA_*" 
("RAM_DATA_BYTE", "RAM_DATA_WORD", "RAM_DATA_DOUBLE_WORD") or "ROM_DATA_*" 
("ROM_DATA_BYTE", "ROM_DATA_WORD", "ROM_DATA_DOUBLE_WORD") macros use the 
associated macros.
			Example:
				uint8_t SBox1Value = READ_SBOX1_DATA_BYTE(SBox1[0]);
				uint16_t SBox2Value = READ_SBOX2_DATA_WORD(SBox2[0]);
				uint32_t SBoxValue = READ_RAM_DATA_WORD(SBox[0]);

		d. Implement the decryption in "decrypt.c" using the "crypto_aead.h" API.

			Note: To read the value of the round key use the "READ_ROUND_KEY_*"
("READ_ROUND_KEY_BYTE", "READ_ROUND_KEY_WORD", "READ_ROUND_KEY_DOUBLE_WORD") 
macro. It allows to read the round keys from RAM or Flash/ROM depending on the 
scenario.
			Example:
				uint8_t ramRK[0] = READ_ROUND_KEY_BYTE(roundKey[0]);
				uint16_t ramRK[0] = READ_ROUND_KEY_WORD(roundKey[0]);
				uint32_t ramRK[0] = READ_ROUND_KEY_DOUBLE_WORD(roundKey[0]);
			Note: To read data types based on "RAM_DATA_*" 
("RAM_DATA_BYTE", "RAM_DATA_WORD", "RAM_DATA_DOUBLE_WORD") or "ROM_DATA_*" 
("ROM_DATA_BYTE", "ROM_DATA_WORD", "ROM_DATA_DOUBLE_WORD") macros use the 
associated macros.
			Example:
				uint8_t SBox1Value = READ_SBOX1_DATA_BYTE(SBox1[0]);
				uint16_t SBox2Value = READ_SBOX2_DATA_WORD(SBox2[0]);
				uint32_t SBoxValue = READ_RAM_DATA_WORD(SBox[0]);

		e. Add a description of your implementation in "implementation.info" 
file, in the "ImplementationDescription:" section.
			Example:
				ImplementationDescription: LBlock small code size

		f. If you have common functions used by two or more of the following
operations (encrypt, decrypt), you can add them in separate "*.c" and "*.h"
files according with the following rules. The same rules apply when you just
want to make the code cleaner by implementing some functions in separate files.

			* Do not use the following names for the added "*.c" and/or "*.h" 
files:
				"main"
				"cipher"
				"scenario1"
				"common"
				"constants"
				"test_vectors"
				"encrypt" 
				"decrypt"

			* Add the "*.c" name withouth the "." separator and extension in
 "implementation.info" file, in the corresponding section(s) ("EncryptCode:",
 "DecryptCode:"). If a section contains more than one file, use ", " as
 separator.
			
			Example:
				- if you add the following files:
					+ "f.c" that contains common code parts for encryption and 
decryption
					+ "g.c" that contains common code parts for encryption
					+ "h.c" that contains a part of the encryption code

				- the "implementation.info" file should contain:
					EncryptCode: f, g, h
					DecryptCode: f

		g. Indicate the implementation language for all supported platforms in 
"implementation.info" file.
			Example:
				ImplementationAVR: ASM
				ImplementationMSP: C
				ImplementationARM: ASM
				ImplementationPC: 
			Note: You don't have to set the implementation language to "C" 
because this is the default value.

	4. Fill the cipher implementation authors in "implementation.info"
		Example:
			ImplementationAuthors: John Doe



Coding rules
============

1. Do not use the following data types: int, char, short, long and the 
combinations of them. Instead use: int8_t, uint8_t, int16_t, uint16_t, int32_t, 
uint32_t, int64_t and uint64_t data types which are declared in "<stdint.h>".

2. Try to keep the code clean and easy to read.

3. Use the "/* ... */" comment style, unless you comment a set of test vectors, 
in which case is indicated to use "// ...".

4. The framework is designed with several debug and test cases, so you should 
not add "printf" or other function calls in your code, at least not in the final 
version.


Constraints
===========

1. The implemented cipher should have a block size "BLOCK_SIZE" that divides 
the "DATA_SIZE" or is equal with the "DATA_SIZE" which is set to 128 bytes in 
scenario 1.

2. The values defined in "constants.h" for "BLOCK_SIZE", and "KEY_SIZE" must be
in bytes.



Getting the cipher metrics
==========================

1. Code Size
From the cipher build directory type one of the following commands to see how to 
use the cipher code size script:
	./../../../../scripts/cipher/cipher_code_size.sh -h
	./../../../../scripts/cipher/cipher_code_size.sh --help


2. RAM
From the cipher build directory type one of the following commands to see how to 
use the cipher RAM script:
	./../../../../scripts/cipher/cipher_ram.sh -h 
	./../../../../scripts/cipher/cipher_ram.sh --help


3. Execution Time
From the cipher build directory type one of the following commands to see how to 
use the cipher execution time script:
	./../../../../scripts/cipher/cipher_execution_time.sh -h 
	./../../../../scripts/cipher/cipher_execution_time.sh --help


4. Collect all metrics
To get help about how to collect all metrics for a list of ciphers on a list of 
architectures in a list of scenarios use:
	./../../../../scripts/collect_ciphers_metrics.sh -h
	./../../../../scripts/collect_ciphers_metrics.sh -help

To get all metrics for "LBlock_64_80_v01" and "LBlock_64_80_v03" on "PC" and 
"ARM" in scenario "1" in raw format use:
	./../../../../scripts/collect_ciphers_metrics.sh -a='PC ARM' -s='1'
-c='LBlock_64_80_v01 LBlock_64_80_v02' -f=1
